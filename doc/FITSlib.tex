\documentclass[a4paper,10pt]{article}
%\documentclass{ia2-template}
%\docnumber{XXX-YYY}
%\docrevision{0.1w}
%% note: date must be a number nnnn-nn-nn
%\docdate{2017-02-23}
%\doctitle{Access to files which are external to Ada}
%\authors{Norbert Levay}
%\approvedby{-}
              
\usepackage[top=5.2cm, left=2cm, right=2cm, bottom=2cm, headheight=2.6cm]{geometry}%showframe
\usepackage{minted}
\usepackage{graphicx}
%\usepackage{listings}

% for testing use this code instea i2-template
%\newcommand{\code}[1]{ \texttt{ \detokenize{#1} } }
\newcommand{\fixme}[1]{\textbf{\textcolor{red}{FIXME #1}}}

%\newcommand{\adacode}[1]{\begin{minted}{ada}{#1}\end{minted}}

\begin{document}

%\printsummary
\tableofcontents

\section{FITS library}


\section{Algorithms}

Supported data structures: image, random groups, ascii table, bin table.

Functionality:

- endianness

- implicit type conversion (Tm Tc Tf)

- scaling

- integrity checksums

- compression



\subsection{File}
It implements FITS\_IO which is based on streams (in case of GNAT C-Streams FILE*) similarly to Streams\_IO implementation.



\subsubsection{Positioning to HDU}

To reach a HDU given by HDUNum first parse header's mandatory keywords and use Eq(X)
to calulate Data Unit size. 


\subsubsection{Header and Data access Rules}

2 Rules:

\textbf{RULE} \textbf{Raw-side/type} is defined by Header in BOTH cases Read/Write

\textbf{RULE} Each invocation of DataUnit.Read/Write modifies File.Index only, as it shifts through the Data\_Unit sequentially (e.g. implements \textbf{sequential access}, no state variable needed).

\textit{NOTE: ergo, there needs to be a Data\_Unit.Init/Open... func AFTER Header is ready and T is known (Data\_Unit instantiated), but BEFORE repeated calls to DU Read/Write start.}

.

additional 2 Rules:

\textbf{RULE} Header is DU-Type independent (Strings,?Floats?)

\textbf{RULE} Data\_Unit package is generic by T and so defines \textbf{Physical-side/type}

\textit{NOTE: the Header is METADATA by its character, and as such it merely DESCRIBES
the Raw-data. Whereas the Data\_Unit contains the data itself and as such it IMPLEMENTS
the data and so defines the Physical-side/type.}

additional 3 rules decribing relation between Header-Data:

\textbf{RULE} Header is read sequentially (because size unknown, must read until END-card)

\textbf{RULE} Data-unit read/write is \textbf{random access} (because size known from the header)

\textbf{RULE} Read\_Header() funcs (unlike Read\_/Write\_Cards):
always reads all header, up to END\_Card (incl padding: skip at read), (after access
File.Index points to first data in the data-unit).





\subsection{Header read write}

\subsubsection{Parser}

Formal Language Theory served as background to capture the rules how cards are placed 
into header. The implementation is a Deterministic Finite Automaton.

Language is a 5-tuple of Alphabet ...
A FITS header is equated to a sentence, where alphabet is a set of keys of the cards.
FITS header alway starts with preamble of mandatory keys, followed by optional (reserved) keys
and always must be closed with a special END-key: MMMMMoooooorrrooorroooooE.


\subsubsection{Internal model and write}



\subsection{Data access}

Functionality of DU unit:

- Endianness

- data conversion and scaling from in-file type into type in computer memory (physical value)

-- marking undefined pixels

- Read Write calls

-- data access to sub-dimesional plane (sequentional access) and sub-cube (random access)



\subsubsection{Endianness}

\subsubsection{Data type conversions}

It is the caller who decides which type of FITS files will the application handle and
which type will be used for data processing. The library handles all possible pairs of
conversions from types in FITS file's data unit to application's type.
Besides conversion in applies the scaling equation Eq(Y).

Implementation relies on template programming due to many types defined by the standard. 
All possible combinations of FITS-types and application's working types are suported
by conversions. It is callers responsability to know whether data value range will fit
into chosen new type in case of downconversions (like from Integer\_32 -> Integer\_16).
Otherwise Constraint\_Error exception will be raised.
Also in case of Floating point types, downconversion comes with loss of precision.

Notes from adb files:

package body Linear\_Conv is

-- NOTE Vin = Vin is check for NaN: for NaN result is False

-- FIXME
    -- cases which involve Float have to deal with NaN as mark for undefined values
    -- FF -> simple: if(NaN) -> Tout(NaN) and Vn\_Types will procide NaN defienitions

    -- FI FU \& no   BLANK from Header -> simply scale, no check
    -- FI FU \& with BLANK from Header -> if(BLANK) -> Tout(NaN)

    -- IF UF -> what BLANK to use if NaN encoutered in Vin ? -> Ask user to provide BLANK (he must know the data-range, should be able to provide BLANK
    -- IF UF -> no   BLANK -> user did not give BLANK, but NaN found -> raise exception "Data contains undefined values (NaN) but no BLANK given"
    -- IF UF -> with BLANK -> if(NaN) -> return BLANK \& check that no value after conversion results in BLANK: if(Vout=BLANK) raise exception "BLANK among valid values"





\subsubsection{Positioning within Data Unit}




\subsection{External interface(s)}
\subsubsection{NCube}







\section{Source inserts}

%\subsection{Specification fits.ads}
%\inputminted[linenos, fontsize=\footnotesize]{ada}{../lib/src/fits.ads}

\subsection{Specification file/file.ads}
\inputminted[linenos, fontsize=\footnotesize]{ada}{../lib/src/file/file.ads}

\subsection{Specification parser/mandatory.ads}
\inputminted[linenos, fontsize=\footnotesize]{ada}{../lib/src/parser/mandatory.ads}

%\subsection{Specification image/alt\_4/physical\_read.ads}
%\inputminted[linenos, fontsize=\footnotesize]{ada}{../lib/src/image/alt_4/physical_read.ads}

%\subsection{Specialization for data types as of FITS ver 3 (api/alt\_4/v3\_image\_read.ads)}
%\inputminted[linenos, fontsize=\footnotesize]{ada}{../lib/src/api/alt_4/v3_image_read.ads}

\end{document}



