\documentclass[a4paper,10pt]{article}
%\documentclass{ia2-template}
%\docnumber{XXX-YYY}
%\docrevision{0.1w}
%% note: date must be a number nnnn-nn-nn
%\docdate{2017-02-23}
%\doctitle{Access to files which are external to Ada}
%\authors{Norbert Levay}
%\approvedby{-}
              
\usepackage[top=5.2cm, left=2cm, right=2cm, bottom=2cm, headheight=2.6cm]{geometry}%showframe
\usepackage{minted}
\usepackage{graphicx}
%\usepackage{listings}

% for testing use this code instea i2-template
%\newcommand{\code}[1]{ \texttt{ \detokenize{#1} } }
\newcommand{\fixme}[1]{\textbf{\textcolor{red}{FIXME #1}}}

%\newcommand{\adacode}[1]{\begin{minted}{ada}{#1}\end{minted}}

\begin{document}

%\printsummary
\tableofcontents

\section{FITS library}


\section{Algorithms}



\subsection{File}
It is based on Stream\_IO ...
\subsubsection{Positioning to HDU}

To reach a HDU given by HDUNum first parse header's mandatory keywords and use Eq(X)
to calulate Data Unit size. 



\subsection{Header read write}

\subsubsection{Parser}

Formal Language Theory served as background to capture the rules how cards are placed 
into header. The implementation is a Deterministic Finite Automaton.

Language is a 5-tuple of Alphabet ...
A FITS header is equated to a sentence, where alphabet is a set of keys of the cards.
FITS header alway starts with preamble of mandatory keys, followed by optional (reserved) keys
and always must be closed with a special END-key: MMMMMoooooorrrooorroooooE.


\subsubsection{Internal model and write}



\subsection{Data access}

Functionality of DU unit: 
- Endianness
- data conversion and scaling from in-file type into type in computer memory (physical value)
-- marking undefined pixels
- Read Write calls
-- data access to sub-dimesional plane (sequentional access) and sub-cube (random access)


\subsubsection{Endianness}

\subsubsection{Data type conversions}

It is the caller who decides which type of FITS files will the application handle and
which type will be used for data processing. The library handles all possible pairs of
conversions from types in FITS file's data unit to application's type.
Besides conversion in applies the scaling equation Eq(Y).

Implementation relies on template programming due to many types defined by the standard. 
All possible combinations of FITS-types and application's working types are suported
by conversions. It is callers responsability to know whether data value range will fit
into chosen new type in case of downconversions (like from Integer\_32 -> Integer\_16).
Otherwise Constraint\_Error exception will be raised.
Also in case of Floating point types, downconversion comes with loss of precision.


\subsubsection{Positioning within Data Unit}




\subsection{External interface(s)}
\subsubsection{NCube}







\section{Source insert example}

\subsection{Specification FITS}
\inputminted{ada}{../lib/src/fits.ads}

\subsection{Specification File}
\inputminted{ada}{../lib/src/file.ads}

\subsection{Specification Header parser}
\inputminted{ada}{../lib/src/parser/strict.ads}

\subsection{Specification Data access}
\inputminted{ada}{../lib/src/data/generic_data_value.ads}
\inputminted{ada}{../lib/src/data/generic_data_unit.ads}

\subsection{Specification NCube}
\inputminted{ada}{../lib/src/ncube/ncube_funcs.ads}
\inputminted{ada}{../lib/src/ncube/ncube.ads}


%\subsection{commands}

%Specification commands.ads
%\inputminted{ada}{../commands.ads}

%Body commands.adb
%\inputminted{ada}{../commands.adb}

%\subsection{main}

%Body main.adb
%\inputminted{ada}{../main.adb}

\end{document}



