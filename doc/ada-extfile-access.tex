\documentclass[a4paper,10pt]{article}
%\documentclass{ia2-template}
%\docnumber{XXX-YYY}
%\docrevision{0.1w}
%% note: date must be a number nnnn-nn-nn
%\docdate{2017-02-23}
%\doctitle{Access to files which are external to Ada}
%\authors{Norbert Levay}
%\approvedby{-}
              
\usepackage[top=5.2cm, left=2cm, right=2cm, bottom=2cm, headheight=2.6cm]{geometry}%showframe
\usepackage{minted}
\usepackage{graphicx}
%\usepackage{listings}

% for testing use this code instea i2-template
%\newcommand{\code}[1]{ \texttt{ \detokenize{#1} } }
\newcommand{\fixme}[1]{\textbf{\textcolor{red}{FIXME #1}}}

\begin{document}

%\printsummary
\tableofcontents

\section{Motivation}

Writing software which internally generates files and reads them back can use
Ada specification. However writing software which reads files generated by other
programming languages, or are defined by standards requires knowledge of specific Ada compiler
implementation. Ada specification does not specify fully all datails of file access properties 
(truncation when write), data positioning in external file and data encoding details.

\section{Ada / GNAT Specifications}
\label{sec:adagnatdocs}

The relevant specs are:

\begin{tabular}{ l l  }
 Title                               &  Ref.                                                \\
\hline
 Ada Reference Manual                &  http://ada-auth.org/standards/12rm/html/RM-TOC.html \\
 GNAT Reference Manual               &  http://docs.adacore.com/gnat\_rm-docs/html/gnat\_rm/gnat\_rm.html \\
 GNAT User's Manual                  &  https://gcc.gnu.org/onlinedocs/gcc-4.8.1/gnat\_ugn\_unw.pdf \\
\end{tabular}


\section{Ada / GNAT file handling}
\label{sec:adagnatfilehandling}

For file handling Ada defines several packages: Text\_IO, Sequential\_IO, Direct\_IO, Stream\_IO.

\begin{center}
\begin{tabular}{ l l l  }
 Title         &  View                                                \\
\hline
Text\_IO       &  Text file consists of characters, those form lines, lines form pages.  \\
               &  There are delimiters between lines and between pages.  \\
               &  Only sequential access possible. \\
\hline
Sequential\_IO &  File is a sequence of data records. If unconstrained also size is stored. \\
               &  Only sequential access possible. \\
\hline
Direct\_IO     &  File is sequence of equal data records of the same size. \\
               &  Random access to any data record possible. \\
\hline
Stream\_IO     &  File is a sequence of different serialized data types.  \\
               &  Smallest unit is Stream\_Element which depends on compiler implementation.  \\
               &  Random access by Stream\_Element possible.  \\
\hline
\end{tabular}
\end{center}



Ada language specification leaves undefined some aspects, which are fixed by
a concrete compiler implementation. In case of file handling, the GNAT compiler
implements the Ada IO-packages with C-streams (FILE* and the family of fopen, fread, fwrite etc... functions).

To access a file not generated by Ada, in general, a fully flexible access is needed:
freely position in file, full control over content (bits) written to file 
(e.g. data layout in memory versus data layout in external file). 
And when updating such files, we need to know which modes do not truncate file content.

Full knowledge about eventual control sequences, data translation or any extra information written to, or 
expected to be read from a file.

Ada file access packages are summarized in following table:

\begin{table}[!h]
\footnotesize
\caption{File access packages summary}
\label{tab:datasets}
\begin{center}
\begin{tabular}{|l|c|c|c|l|}
\hline
\textbf{IO Package}& \textbf{Indexing}   & \textbf{File Mode}   & \textbf{Modify file}     & \textbf{Alignment}  \\
                   &                     & \textbf{in Open file}& \textbf{without truncate}& \textbf{--}         \\ 
\hline
  Text\_IO*        &   no                & In Out Append        & no:  Out\_File is "w"    &                     \\ 
\hline
  Sequential\_IO   &   no                & In Out Append        & no:  Out\_File is "w"    & Fixed size data: sequence of memory images     \\ 
                   &                     &                      &                          & Variable size  : first size written, then data \\ 
\hline
  Direct\_IO       &   yes               & In Inout Out         & yes: Inout\_File is "r+" & Record'Size rounded up ro next storage boundary \\ 
                   &                     &                      &                          & GNAT: no gaps between records                   \\ 
\hline
  Stream\_IO**     &   yes               & In Out Append        & no:  Out\_File is "w"    & GNAT: Stream\_Element is byte           \\ 
%\hline
                   &                     &                      & yes: Set\_Mode()  "r+"   &                     \\
\hline
\end{tabular}
\end{center}
\end{table}
* Text\_IO.Stream sub package provides Stream access, and then text file can be handled as stream, ergo Stream\_IO properties apply.

** Stream\_IO in GNAT implementation would swicth to "r+" mode if Set\_Mode called to change the mode of an opened file.

C-streams define following modes for file open:
\begin{itemize}
\item \textbf{'r'}: Open an existing file for reading only. 
\item \textbf{'w'}: Open the file for writing only. If the file already exists, it is truncated to zero length. Otherwise a new file is created. 
\item \textbf{'a'}: Open a file for append access; that is, writing at the end of file only. If the file already exists, its initial contents are unchanged and output to the stream is appended to the end of the file. Otherwise, a new, empty file is created. 
\item \textbf{'r+'}: Open an existing file for both reading and writing. The initial contents of the file are unchanged and the initial file position is at the beginning of the file. 
\item \textbf{'w+'}: Open a file for both reading and writing. If the file already exists, it is truncated to zero length. Otherwise, a new file is created. 
\item \textbf{'a+'}: Open or create file for both reading and appending. If the file exists, its initial contents are unchanged. Otherwise, a new file is created. The initial file position for reading is at the beginning of the file, but output is always appended to the end of the file. 
\end{itemize}



\subsection{FITS\_IO file modes and write behaviour}

\begin{verbatim}
-- FIXME reconsider Open/Create + File_mode rules / add to doc:
-- valid combinations:
-- Open   : In Inout Append
-- Create : Append
-- Write behaviour:
-- Open   + Out_File    -> Write(...,HDU_Num) truncates FITS-File and appends Header to the truncated end
-- Open   + Inout_File  -> Write(...,HDU_Num) overwrites HDU if sizes match (sizes counted in Blocks = 2880bytes)
-- Open/Create + Append -> Write() (call without HDU_Num ) appends to the end
\end{verbatim}

\subsection{Buffering}
\label{sec:webbrowser}

\fixme{How is buffering specified on Ada level, implemented by GNAT and by C-streams ?}

Here an example with Ada mint. 
\begin{minted}{ada}
type File_Mode is (In_File, Inout_File, Out_File);  --  for Direct_IO
type File_Mode is (In_File, Out_File, Append_File);
--  for Sequential_IO, Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, and Stream_IO
\end{minted} 

%\section{Figure insert example}
%Here is ref to a Figure \ref{fig:system}.
%\begin{figure}[ht]
%\begin{center}
%\includegraphics[width=\textwidth]{vlkb_radiocube_services.pdf}
%\caption{System overview}
%\label{fig:system}
%\end{center}
%\end{figure}
%
%But figure is not inserted.

\section{Dependencies}

FITS standard defines a Byte as group of 8-bits with big-endian 
interpretation oridering. \fixme{bit ordering or word ordering?}

Implement as much as Direct\_IO, Stream\_IO (or othe Ada I/O libs) C-Streams assume.

\subsection{Memory unit size}

\begin{verbatim}
 -- Terminology: Byte - Storage_Unit - Stream_Element
 -- [GNAT,9.8 Stream_IO] "The type Stream_Element is simply a byte."
 -- [Ada2005, 13.7 The Package 'System'] "Storage_Unit The number of bits per storage element."
 -- [GNAT,2 Implementation Defined Atrributes ->Bit] "...from System.Storage_Unit (=Byte)..."

 -- [FITS 2.2 Defined Terms] "Byte An ordered sequence of eight consecutive bits treated as a single entity."
 -- [FITS 3.1 Overall file structure] "...FITS blocks which are each 2880 bytes (23040 bits) in length."

-- What Index points to is in Ada but currently removed (overstriked):
-- [AdaA.12.1 The Package Streams.Stream_IO]:
--   {8652/0055} The Index function returns the current file index, as a count (in stream elements) from the beginning of the file. The position of the first element in the file is 1.
-- 31.a/1
-- This paragraph was deleted. Ramification: The notion of Index for Stream_IO is analogous
-- to that of Index in Direct_IO, except that the former is measured in Stream_Element units,
-- whereas the latter is in terms of Element_Type values.

-- [GNAT Determining the Representation Chosen by GNAT] -gnatR switch prints GNAT representation of types

-- Character: in Ada an enum of 256 literal chars, in GNAT such maps to 8bits :
-- [GNAT 11.1 Interfacing to C] Without pragma Convention C, Ada enumeration types map to 8, 16, or 32 bits
-- ... depending on the number of values passed.
-- [Ada] "An enumeration type is said to be a character type if at least one of its enumeration literals is a character_literal."
-- The predefined type Character is a character type whose values correspond to the 256 code points of Row 00 (also known as Latin-1) of the ISO/IEC 10646:2011 Basic Multilingual Plane (BMP).
-- See [Ada A.1 tha Package Standard]-> type Character is (....256 chars listed );

 -- FIXME not implemented yet: Use System.Storage_Unit to implement BlockIndex<->OctetIndex calc
 -- Bloc_Size in Storage units:
 -- BlockSize is in FITS-Bytes (=8bits)
 -- BlockSize_SU := BlockSize / (System.Storage_Unit/8)
 -- this would work for multiple 16 32 ... Storage_Unit's: yields correct addressing,
 -- but how to guarantee that Read/Write will put 2 FITS-Characters into one 16-bit character for instance?
\end{verbatim}



\subsection{Endianness}

Endianness exists on two levels: order of bits in byte, 
and order of bytes in word.

\begin{verbatim}
 -- FIXME endianness not implemented yet:
 -- Ada's Bit_Order uses big/little endianness with reference to bit-ordering, not byte ordering.
 -- [Ada 13.5.3 Bit Ordering] High_Order_First = big-endian, Low_Order_First  = little-endian
 -- Byte ordering (swapping if needed) supported by [GNAT] attrib Scalar_Storage_Order:
 -- [GNAT 2 Implementation Defined Attributes] 'Scalar_Storage_Order has same values as Ada's Bit_Order.
 -- gnatmake: says it is unrecognized attrib: for DataArray_Type'Scalar_Storage_Order use System.High_Order_First;
 -- [GNAT] "Note that the scalar storage order only affects the in-memory data representation.
 -- It has no effect on the representation used by stream attributes."
 -- [FITS 3.3.2 Primary data array]: "The individual data values shall be stored in big-endian byte order..."
 -- [FITS 5 Data Representation & 7.3.3]: "Bytes are in big-endian order of decreasing significance."
 -- [FITS 5 ] "Bytes are in big-endian order of decreasing significance.
 -- The byte that includes the sign bit shall be first, and the byte that
 -- has the ones bit shall be last."
 -- Note: Byte is defined by [FITS] as 8bits.
\end{verbatim}

\section{Definitions}

\begin{itemize}
\item \textbf{bit}: result of binary decision, yes/no.
\item \textbf{byte}: smallest addressable consecutive array of bits in a given computer memory architecture
\item \textbf{word}: register size (in bits) in which CPU performes arithmetical operations
\end{itemize}




\section{Source insert example}

\subsection{FITS\_IO}

Specification fits\_io.ads
\inputminted{ada}{../fits_io.ads}

Body fits\_io.adb
\inputminted{ada}{../fits_io.adb}

Specification hdu.ads
\inputminted{ada}{../hdu.ads}

Body hdu.adb
\inputminted{ada}{../hdu.adb}


\subsection{commands}

Specification commands.ads
\inputminted{ada}{../commands.ads}

Body commands.adb
\inputminted{ada}{../commands.adb}

%\subsection{main}

%Body main.adb
%\inputminted{ada}{../main.adb}

\end{document}



