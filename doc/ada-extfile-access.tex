\documentclass[a4paper,10pt]{article}
%\documentclass{ia2-template}
%\docnumber{XXX-YYY}
%\docrevision{0.1w}
%% note: date must be a number nnnn-nn-nn
%\docdate{2017-02-23}
%\doctitle{Access to files which are external to Ada}
%\authors{Norbert Levay}
%\approvedby{-}
              
\usepackage[top=5.2cm, left=2cm, right=2cm, bottom=2cm, headheight=2.6cm]{geometry}%showframe
\usepackage{minted}
\usepackage{graphicx}
%\usepackage{listings}

% for testing use this code instea i2-template
%\newcommand{\code}[1]{ \texttt{ \detokenize{#1} } }
\newcommand{\fixme}[1]{\textbf{\textcolor{red}{FIXME #1}}}

\begin{document}

%\printsummary
\tableofcontents

\section{Motivation}

Writing software which internally generates files and reads them back can use
Ada specification. However writing software which reads files generated by other
programming languages, or are defined by standards requires knowledge of specific Ada compiler
implementation. Ada specification does not specify fully all datails of file access properties 
(truncation when write), data positioning in external file and data encoding details.

\section{Ada / GNAT Specifications}
\label{sec:adagnatdocs}

The relevant specs are:

\begin{tabular}{ l l  }
 Title                               &  Ref.                                                \\
\hline
 Ada Reference Manual                &  http://ada-auth.org/standards/12rm/html/RM-TOC.html \\
 GNAT Reference Manual               &  http://docs.adacore.com/gnat\_rm-docs/html/gnat\_rm/gnat\_rm.html \\
 GNAT User's Manual                  &  https://gcc.gnu.org/onlinedocs/gcc-4.8.1/gnat\_ugn\_unw.pdf \\
\end{tabular}


\section{Ada / GNAT file handling}
\label{sec:adagnatfilehandling}

For file handling Ada defines several packages: Text\_IO, Sequential\_IO, Direct\_IO, Stream\_IO.

\begin{center}
\begin{tabular}{ l l l  }
 Title         &  View                                                \\
\hline
Text\_IO       &  Text file consists of characters, those form lines, lines form pages.  \\
               &  There are delimiters between lines and between pages.  \\
               &  Only sequential access possible. \\
\hline
Sequential\_IO &  File is a sequence of data records. If unconstrained also size is stored. \\
               &  Only sequential access possible. \\
\hline
Direct\_IO     &  File is sequence of equal data records of the same size. \\
               &  Random access to any data record possible. \\
\hline
Stream\_IO     &  File is a sequence of different serialized data types.  \\
               &  Smallest unit is Stream\_Element which depends on compiler implementation.  \\
               &  Random access by Stream\_Element possible.  \\
\hline
\end{tabular}
\end{center}



Ada language specification leaves undefined some aspects, which are fixed by
a concrete compiler implementation. In case of file handling, the GNAT compiler
implements the Ada IO-packages with C-streams (FILE* and the family of fopen, fread, fwrite etc... functions).

To access a file not generated by Ada, in general, a fully flexible access is needed:
freely position in file, full control over content (bits) written to file 
(e.g. data layout in memory versus data layout in external file). 
And when updating such files, we need to know which modes do not truncate file content.

Full knowledge about eventual control sequences, data translation or any extra information written to, or 
expected to be read from a file.

Ada file access packages are summarized in following table:

\begin{table}[!h]
\footnotesize
\caption{File access packages summary}
\label{tab:datasets}
\begin{center}
\begin{tabular}{|l|c|c|c|l|}
\hline
\textbf{IO Package}& \textbf{Indexing}   & \textbf{File Mode}   & \textbf{Modify file}     & \textbf{Alignment}  \\
                   &                     & \textbf{in Open file}& \textbf{without truncate}& \textbf{--}         \\ 
\hline
  Text\_IO*        &   no                & In Out Append        & no:  Out\_File is "w"    &                     \\ 
\hline
  Sequential\_IO   &   no                & In Out Append        & no:  Out\_File is "w"    & Fixed size data: sequence of memory images     \\ 
                   &                     &                      &                          & Variable size  : first size written, then data \\ 
\hline
  Direct\_IO       &   yes               & In Inout Out         & yes: Inout\_File is "r+" & Record'Size rounded up ro next storage boundary \\ 
                   &                     &                      &                          & GNAT: no gaps between records                   \\ 
\hline
  Stream\_IO**     &   yes               & In Out Append        & no:  Out\_File is "w"    & GNAT: Stream\_Element is byte           \\ 
%\hline
                   &                     &                      & yes: Set\_Mode()  "r+"   &                     \\
\hline
\end{tabular}
\end{center}
\end{table}
* Text\_IO.Stream sub package provides Stream access, and then text file can be handled as stream, ergo Stream\_IO properties apply.

** Stream\_IO in GNAT implementation would swicth to "r+" mode if Set\_Mode called to change the mode of an opened file.

C-streams define following modes for file open:
\begin{itemize}
\item \textbf{'r'}: Open an existing file for reading only. 
\item \textbf{'w'}: Open the file for writing only. If the file already exists, it is truncated to zero length. Otherwise a new file is created. 
\item \textbf{'a'}: Open a file for append access; that is, writing at the end of file only. If the file already exists, its initial contents are unchanged and output to the stream is appended to the end of the file. Otherwise, a new, empty file is created. 
\item \textbf{'r+'}: Open an existing file for both reading and writing. The initial contents of the file are unchanged and the initial file position is at the beginning of the file. 
\item \textbf{'w+'}: Open a file for both reading and writing. If the file already exists, it is truncated to zero length. Otherwise, a new file is created. 
\item \textbf{'a+'}: Open or create file for both reading and appending. If the file exists, its initial contents are unchanged. Otherwise, a new file is created. The initial file position for reading is at the beginning of the file, but output is always appended to the end of the file. 
\end{itemize}




\subsection{Buffering}
\label{sec:webbrowser}

\fixme{How is buffering specified on Ada level, implemented by GNAT and by C-streams ?}

Here an example with Ada mint. 
\begin{minted}{ada}
type File_Mode is (In_File, Inout_File, Out_File);  --  for Direct_IO
type File_Mode is (In_File, Out_File, Append_File);
--  for Sequential_IO, Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, and Stream_IO
\end{minted} 

%\section{Figure insert example}
%Here is ref to a Figure \ref{fig:system}.
%\begin{figure}[ht]
%\begin{center}
%\includegraphics[width=\textwidth]{vlkb_radiocube_services.pdf}
%\caption{System overview}
%\label{fig:system}
%\end{center}
%\end{figure}
%
%But figure is not inserted.

\section{Source insert example}

\subsection{FITS\_IO}

Specification fits\_io.ads
\inputminted{ada}{../fits_io.ads}

%Body fits_io.adb
%\inputminted{ada}{../fits_io.adb}

Specification hdu.ads
\inputminted{ada}{../hdu.ads}

Body hdu.adb
\inputminted{ada}{../hdu.adb}


\subsection{commands}

Specification commands.ads
\inputminted{ada}{../commands.ads}

Body commands.adb
\inputminted{ada}{../commands.adb}

%\subsection{main}

%Body main.adb
%\inputminted{ada}{../main.adb}

\end{document}



