\documentclass[a4paper,10pt]{article}
%\documentclass{ia2-template}
%\docnumber{XXX-YYY}
%\docrevision{0.1w}
%% note: date must be a number nnnn-nn-nn
%\docdate{2017-02-23}
%\doctitle{Access to files which are external to Ada}
%\authors{Norbert Levay}
%\approvedby{-}
              
\usepackage[top=5.2cm, left=2cm, right=2cm, bottom=2cm, headheight=2.6cm]{geometry}%showframe
\usepackage{minted}
\usepackage{graphicx}
%\usepackage{listings}

% for testing use this code instea i2-template
%\newcommand{\code}[1]{ \texttt{ \detokenize{#1} } }
\newcommand{\fixme}[1]{\textbf{\textcolor{red}{FIXME #1}}}

%\newcommand{\adacode}[1]{\begin{minted}{ada}{#1}\end{minted}}

\begin{document}

%\printsummary
\tableofcontents

\section{Motivation}

Writing software which internally generates files and reads them back can use
Ada specification. However writing software which reads files generated by other
programming languages, or are defined by standards requires knowledge of specific Ada compiler
implementation. Ada specification does not specify fully all datails of file access properties 
(truncation when write), data positioning in external file and data encoding details.

\section{Ada / GNAT Specifications}
\label{sec:adagnatdocs}

The relevant specs are:

\begin{tabular}{ l l  }
 Title                               &  Ref.                                                \\
\hline
 Ada Reference Manual                &  http://ada-auth.org/standards/12rm/html/RM-TOC.html \\
 GNAT Reference Manual               &  http://docs.adacore.com/gnat\_rm-docs/html/gnat\_rm/gnat\_rm.html \\
 GNAT User's Manual                  &  https://gcc.gnu.org/onlinedocs/gcc-4.8.1/gnat\_ugn\_unw.pdf \\
\end{tabular}


\section{Ada / GNAT file handling}
\label{sec:adagnatfilehandling}

For file handling Ada defines several packages: Text\_IO, Sequential\_IO, Direct\_IO, Stream\_IO.

\begin{center}
\begin{tabular}{ l l l  }
 Title         &  View                                                \\
\hline
Text\_IO       &  Text file consists of characters, those form lines, lines form pages.  \\
               &  There are delimiters between lines and between pages.  \\
               &  Only sequential access possible. \\
\hline
Sequential\_IO &  File is a sequence of data records. If unconstrained also size is stored. \\
               &  Only sequential access possible. \\
\hline
Direct\_IO     &  File is sequence of equal data records of the same size. \\
               &  Random access to any data record possible. \\
\hline
Stream\_IO     &  File is a sequence of different serialized data types.  \\
               &  Smallest unit is Stream\_Element which depends on compiler implementation.  \\
               &  Random access by Stream\_Element possible.  \\
\hline
\end{tabular}
\end{center}



Ada language specification leaves undefined some aspects, which are fixed by
a concrete compiler implementation. In case of file handling, the GNAT compiler
implements the Ada IO-packages with C-streams (FILE* and the family of fopen, fread, fwrite etc... functions).

To access a file not generated by Ada, in general, a fully flexible access is needed:
freely position in file, full control over content (bits) written to file 
(e.g. data layout in memory versus data layout in external file). 
And when updating such files, we need to know which modes do not truncate file content.

Full knowledge about eventual control sequences, data translation or any extra information written to, or 
expected to be read from a file.

Ada file access packages are summarized in following table:

\begin{table}[!h]
\footnotesize
\caption{File access packages summary}
\label{tab:datasets}
\begin{center}
\begin{tabular}{|l|c|c|c|l|}
\hline
\textbf{IO Package}& \textbf{Indexing}   & \textbf{File Mode}   & \textbf{Modify file}     & \textbf{Alignment}  \\
                   &                     & \textbf{in Open file}& \textbf{without truncate}& \textbf{--}         \\ 
\hline
  Text\_IO*        &   no                & In Out Append        & no:  Out\_File is "w"    &                     \\ 
\hline
  Sequential\_IO   &   no                & In Out Append        & no:  Out\_File is "w"    & Fixed size data: sequence of memory images     \\ 
                   &                     &                      &                          & Variable size  : first size written, then data \\ 
\hline
  Direct\_IO       &   yes               & In Inout Out         & yes: Inout\_File is "r+" & Record'Size rounded up ro next storage boundary \\ 
                   &                     &                      &                          & GNAT: no gaps between records                   \\ 
\hline
  Stream\_IO**     &   yes               & In Out Append        & no:  Out\_File is "w"    & GNAT: Stream\_Element is byte           \\ 
%\hline
                   &                     &                      & yes: Set\_Mode()  "r+"   &                     \\
\hline
\end{tabular}
\end{center}
\end{table}
* Text\_IO.Stream sub package provides Stream access, and then text file can be handled as stream, ergo Stream\_IO properties apply.

** Stream\_IO in GNAT implementation would swicth to "r+" mode if Set\_Mode called to change the mode of an opened file.

C-streams define following modes for file open:
\begin{itemize}
\item \textbf{'r'}: Open an existing file for reading only. 
\item \textbf{'w'}: Open the file for writing only. If the file already exists, it is truncated to zero length. Otherwise a new file is created. 
\item \textbf{'a'}: Open a file for append access; that is, writing at the end of file only. If the file already exists, its initial contents are unchanged and output to the stream is appended to the end of the file. Otherwise, a new, empty file is created. 
\item \textbf{'r+'}: Open an existing file for both reading and writing. The initial contents of the file are unchanged and the initial file position is at the beginning of the file. 
\item \textbf{'w+'}: Open a file for both reading and writing. If the file already exists, it is truncated to zero length. Otherwise, a new file is created. 
\item \textbf{'a+'}: Open or create file for both reading and appending. If the file exists, its initial contents are unchanged. Otherwise, a new file is created. The initial file position for reading is at the beginning of the file, but output is always appended to the end of the file. 
\end{itemize}


\subsection{Truncation when writing a file}
\label{sec:truncatefile}

\begin{Verbatim}
Note in (AARM) Annotated Ada Reference Manual, Sect. Ada Streams_IO
(http://www.adaic.org/resources/add_content/standards/05aarm/html/AA-A-12-1.html
\textbf{Ada Reference Manual, ISO/IEC 8652:2007(E) Ed. 3)}:

Inconsistencies With Ada 95
36.a/2
{AI95-00283-01} {inconsistencies with Ada 95} Amendment Correction: 
The description of the subprograms for managing files was corrected so 
that they do not require truncation of the external file  a stream file 
is not a sequential file. An Ada 95 program that expects truncation 
of the stream file may not work under Ada 2005. Note that the Ada 95 standard 
was ambiguous on this point (the normative wording seemed to require truncation, 
but didn't explain where; the AARM notes seemed to expect behavior like 
Direct_IO), and implementations varied widely. Therefore, as a 
practical matter, code that depends on stream truncation may not work 
even in Ada 95; deleting the file before opening it provides truncation that works in 
both Ada 95 and Ada 2005. 
\end{Verbatim}

\begin{Verbatim}
https://www.pegasoft.ca/resources/boblap/16.html

\textbf{The Big Online Book of Linux Ada Programming}:

Abstract

According to studies, GCC Ada may allow you to develop Linux applications 
in half the time compared to C. A language designed for team development and 
included with most Linux distributions, Ada is a language well-suited for 
serious open source development and is superior in many ways to C++ or Java. 
Find out if Ada is right for your project in this 20 chapter reference 
to using Ada on Linux.

...

16.8 Opening and Closing Files

The standard Ada packages Text_IO, Sequential_IO and Direct_IO are suitable 
for simple projects, but they were never intended as a complete solution 
for large-scale applications. If you want to do efficient file manipulation, 
you'll have to write your own routines based on kernel calls or 
the standard C library.

gnat's OSLIB package contains low-level commands to work with UNIX files. 
However, you can always create your own.

\end{Verbatim}



\subsection{FITS\_IO file modes and write behaviour}

\begin{verbatim}
-- FIXME reconsider Open/Create + File_mode rules / add to doc:
-- valid combinations:
-- Open   : In Inout Append
-- Create : Append
-- Write behaviour:
-- Open   + Out_File    -> Write(...,HDU_Num) truncates FITS-File and appends Header to the truncated end
-- Open   + Inout_File  -> Write(...,HDU_Num) overwrites HDU if sizes match (sizes counted in Blocks = 2880bytes)
-- Open/Create + Append -> Write() (call without HDU_Num ) appends to the end
\end{verbatim}

\subsection{Buffering}
\label{sec:webbrowser}

\fixme{How is buffering specified on Ada level, implemented by GNAT and by C-streams ?}

Here an example with Ada mint. 
\begin{minted}{ada}
type File_Mode is (In_File, Inout_File, Out_File);  --  for Direct_IO
type File_Mode is (In_File, Out_File, Append_File);
--  for Sequential_IO, Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, and Stream_IO
\end{minted} 

\subsection{Elementary functions and higher-level HDU utilities}
\label{sec:elemntaryfuncs}

FITS\_IO will implement set of elementary file operations to 
create HDU's. Child package FITS\_IO.Utilities will have higher level
operations for HDU's in FITS-file. Implementation attempts to minimize
FITS-file loss due to system failure 
while performing one of these functions.
When needed, new temporary FITS-files are created, 
and only when ready they are renamed to original file name. 
This avoids leaving a FITS-file in incosistent state
if the operation was interrupted due to power failure or similar.
(Assuming that also rename operation is failure-safe).

The figher level HDU operations are:
\begin{itemize}
\item \textbf{create} new FITS file from scratch
\item \textbf{insert, remove} a HDU from FITS-file
\item \textbf{update} HDU at given position (regardless of new HDU's size)
\item \textbf{save} one HDU to separate FITS-file
\end{itemize}

Later things like: split multi-HDU FITS-file into many FITS-file one HDU each,
remove all extensions, leaving only Primary HDU,
remove all extensions of BINTABLE type or 
remove all extensions which are not IMAGE etc...

HDU's are represented by their Header. 
Data can be added once the HDU
was added to the FITS-file.

Elementary functions in FITS\_IO to support the above are:

\begin{itemize}
\item \textbf{create} new empty FITS-file
\item \textbf{open} an existing FITS-file (if file is zero size do as after create)
\item \textbf{append} to the end of FITS-file a HDU defined by a Header (use: Write + Append\_Mode)
\item \textbf{write} (with truncate) a HDU to given position in 
FITS-file; the HDU at the position and HDU's behind it will be lost
(use: Write + Out\_Mode))
\item \textbf{update} (write without truncate) a HDU in given 
position if HDU sizes match (error otherwise)
(use: Write + Inout\_Mode).
Note: if HDU is last in the FITS-file, 
update is possible even if sizes do not match.
\end{itemize}


%\section{Figure insert example}
%Here is ref to a Figure \ref{fig:system}.
%\begin{figure}[ht]
%\begin{center}
%\includegraphics[width=\textwidth]{vlkb_radiocube_services.pdf}
%\caption{System overview}
%\label{fig:system}
%\end{center}
%\end{figure}
%
%But figure is not inserted.

\section{Dependencies}

FITS standard defines a Byte as group of 8-bits with big-endian 
interpretation oridering. \fixme{bit ordering or word ordering?}

Implement as much as Direct\_IO, Stream\_IO (or othe Ada I/O libs) C-Streams assume.

\subsection{Memory unit size}

\begin{verbatim}
 -- Terminology: Byte - Storage_Unit - Stream_Element
 -- [GNAT,9.8 Stream_IO] "The type Stream_Element is simply a byte."
 -- [Ada2005, 13.7 The Package 'System'] "Storage_Unit The number of bits per storage element."
 -- [GNAT,2 Implementation Defined Atrributes ->Bit] "...from System.Storage_Unit (=Byte)..."

 -- [FITS 2.2 Defined Terms] "Byte An ordered sequence of eight consecutive bits treated as a single entity."
 -- [FITS 3.1 Overall file structure] "...FITS blocks which are each 2880 bytes (23040 bits) in length."

-- What Index points to is in Ada but currently removed (overstriked):
-- [AdaA.12.1 The Package Streams.Stream_IO]:
--   {8652/0055} The Index function returns the current file index, as a count (in stream elements) from the beginning of the file. The position of the first element in the file is 1.
-- 31.a/1
-- This paragraph was deleted. Ramification: The notion of Index for Stream_IO is analogous
-- to that of Index in Direct_IO, except that the former is measured in Stream_Element units,
-- whereas the latter is in terms of Element_Type values.

-- [GNAT Determining the Representation Chosen by GNAT] -gnatR switch prints GNAT representation of types

-- Character: in Ada an enum of 256 literal chars, in GNAT such maps to 8bits :
-- [GNAT 11.1 Interfacing to C] Without pragma Convention C, Ada enumeration types map to 8, 16, or 32 bits
-- ... depending on the number of values passed.
-- [Ada] "An enumeration type is said to be a character type if at least one of its enumeration literals is a character_literal."
-- The predefined type Character is a character type whose values correspond to the 256 code points of Row 00 (also known as Latin-1) of the ISO/IEC 10646:2011 Basic Multilingual Plane (BMP).
-- See [Ada A.1 tha Package Standard]-> type Character is (....256 chars listed );

 -- FIXME not implemented yet: Use System.Storage_Unit to implement BlockIndex<->OctetIndex calc
 -- Bloc_Size in Storage units:
 -- BlockSize is in FITS-Bytes (=8bits)
 -- BlockSize_SU := BlockSize / (System.Storage_Unit/8)
 -- this would work for multiple 16 32 ... Storage_Unit's: yields correct addressing,
 -- but how to guarantee that Read/Write will put 2 FITS-Characters into one 16-bit character for instance?
\end{verbatim}

\subsection{Derivation of Positive\_Count type used for Index}

In Ada.Streams :

\begin{minted}{ada}
   type Stream_Element_Offset is range
     -(2 ** (Standard'Address_Size - 1)) ..
     +(2 ** (Standard'Address_Size - 1)) - 1;
\end{minted}

where \textbf{Address Size} is [GNAT 2. Implementation defined attributes]:

Standard'Address\_Size (Standard is the only allowed prefix) is a static constant giving
the number of bits in an Address. It is the same value as System.Address'Size, but has
the advantage of being static, while a direct reference to System.Addressâ€™Size is non-static
because Address is a private type.


And then in Ada.Streams.Stream\_IO :

\begin{minted}{ada}
   type Count is new Stream_Element_Offset
     range 0 .. Stream_Element_Offset'Last;

   subtype Positive_Count is Count range 1 .. Count'Last;
   --  Index into file, in stream elements


   procedure Set_Index (File : File_Type; To : Positive_Count);

   function Index (File : File_Type) return Positive_Count;
   function Size  (File : File_Type) return Count;



   type Stream_AFCB is new FCB.AFCB with record
      Index : Count := 1;
      --  Current Index value

      File_Size : Stream_Element_Offset := -1;
      --  Cached value of File_Size, so that we do not keep recomputing it
      --  when not necessary (otherwise End_Of_File becomes gruesomely slow).
      --  A value of minus one means that there is no cached value.

      Last_Op : Operation := Op_Other;
      --  Last operation performed on file, used to avoid unnecessary
      --  repositioning between successive read or write operations.

      Update_Mode : Boolean := False;
      --  Set if the mode is changed from write to read or vice versa.
      --  Indicates that the file has been reopened in update mode.

   end record;

   type File_Type is access all Stream_AFCB;

\end{minted}

However in System.Direct\_IO:

\begin{minted}{ada}
   subtype Count is Interfaces.C_Streams.long;
   --  The Count type in each instantiation is derived from this type

   subtype Positive_Count is Count range 1 .. Count'Last;

   type Direct_AFCB is new FCB.AFCB with record
      Index : Count := 1;
      --  Current Index value

      Bytes : Interfaces.C_Streams.size_t;
      --  Length of item in bytes (set from inside generic template)

      Last_Op : Operation := Op_Other;
      --  Last operation performed on file, used to avoid unnecessary
      --  repositioning between successive read or write operations.
   end record;

   type File_Type is access all Direct_AFCB;
   --  File_Type in individual instantiations is derived from this type
\end{minted}

and finally in Ada.Direct\_IO:

\begin{minted}{ada}
   type Count is range 0 .. System.Direct_IO.Count'Last;

   subtype Positive_Count is Count range 1 .. Count'Last;

   type File_Type is new System.Direct_IO.File_Type;

   procedure Set_Index (File : File_Type; To : Positive_Count);

   function Index (File : File_Type) return Positive_Count;
   function Size  (File : File_Type) return Count;

\end{minted}




\subsection{Endianness}

Endianness exists on two levels: order of bits in byte, 
and order of bytes in word.

\begin{verbatim}
 -- FIXME endianness not implemented yet:
 -- Ada's Bit_Order uses big/little endianness with reference to bit-ordering, not byte ordering.
 -- [Ada 13.5.3 Bit Ordering] High_Order_First = big-endian, Low_Order_First  = little-endian
 -- Byte ordering (swapping if needed) supported by [GNAT] attrib Scalar_Storage_Order:
 -- [GNAT 2 Implementation Defined Attributes] 'Scalar_Storage_Order has same values as Ada's Bit_Order.
 -- gnatmake: says it is unrecognized attrib: for DataArray_Type'Scalar_Storage_Order use System.High_Order_First;
 -- [GNAT] "Note that the scalar storage order only affects the in-memory data representation.
 -- It has no effect on the representation used by stream attributes."
 -- [FITS 3.3.2 Primary data array]: "The individual data values shall be stored in big-endian byte order..."
 -- [FITS 5 Data Representation & 7.3.3]: "Bytes are in big-endian order of decreasing significance."
 -- [FITS 5 ] "Bytes are in big-endian order of decreasing significance.
 -- The byte that includes the sign bit shall be first, and the byte that
 -- has the ones bit shall be last."
 -- Note: Byte is defined by [FITS] as 8bits.
\end{verbatim}

\section{Definitions}

\begin{itemize}
\item \textbf{bit}: result of binary decision, yes/no.
\item \textbf{byte}: smallest addressable consecutive array of bits in a given computer memory architecture
\item \textbf{word}: register size (in bits) in which CPU performes arithmetical operations
\end{itemize}




\section{Source insert example}

\subsection{FITS\_IO}

Specification FITS
\inputminted{ada}{../lib/src/fits.ads}

Specification File
\inputminted{ada}{../lib/src/fits-file.ads}

Specification Header
\inputminted{ada}{../lib/src/fits-header.ads}

Specification Data
\inputminted{ada}{../lib/src/fits-data.ads}

Parser specs
\inputminted{ada}{../lib/src/fits-parser.ads}


%\subsection{commands}

%Specification commands.ads
%\inputminted{ada}{../commands.ads}

%Body commands.adb
%\inputminted{ada}{../commands.adb}

%\subsection{main}

%Body main.adb
%\inputminted{ada}{../main.adb}

\end{document}



